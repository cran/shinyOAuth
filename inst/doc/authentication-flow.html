<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Authentication flow</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>







<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Authentication flow</h1>



<div id="overview" class="section level2">
<h2>Overview</h2>
<p>This vignette provides a step-by-step description of what happens
during an authentication flow when using the
<code>oauth_module_server()</code> Shiny module. It maps protocol
concepts (OAuth 2.0 Authorization Code + PKCE, OpenID Connect) to the
concrete implementation details in the package.</p>
<p>For a concise quick-start (minimal and manual button examples,
options, and security checklist) see:
<code>vignette(&quot;usage&quot;, package = &quot;shinyOAuth&quot;)</code>.</p>
<p>For an explanation of logging key events during the flow, see:
<code>vignette(&quot;audit-logging&quot;, package = &quot;shinyOAuth&quot;)</code>.</p>
</div>
<div id="what-happens-during-the-authentication-flow" class="section level2">
<h2>What happens during the authentication flow?</h2>
<p>The package implements the OAuth 2.0 ‘Authorization Code’ flow and
optional ‘OpenID Connect’ (OIDC) checks end‑to‑end. Below is the
sequence of operations and the rationale behind each step.</p>
<div id="first-page-load-set-a-browser-token" class="section level3">
<h3>1. First page load: set a browser token</h3>
<p>On the first load of your app, the module sets a small random cookie
in the user’s browser (SameSite=Strict; Secure when over HTTPS). This
browser token is mirrored to Shiny as an input. Its purpose is to ensure
that the same browser that starts the OAuth flow is the one that
finishes it (a “double-submit” style CSRF defense).</p>
</div>
<div id="decide-whether-to-start-login" class="section level3">
<h3>2. Decide whether to start login</h3>
<p>If <code>oauth_module_server(auto_redirect = TRUE)</code>, an
unauthenticated session triggers immediate redirection to the provider
authorization endpoint.</p>
<p>If <code>oauth_module_server(auto_redirect = FALSE)</code>, you
manually call <code>$request_login()</code> (e.g., via a button) to do
so.</p>
</div>
<div id="build-the-authorization-url-prepare_call" class="section level3">
<h3>3. Build the authorization URL (<code>prepare_call()</code>)</h3>
<p>To redirect the user to the provider, the module constructs an
authorization request URL. The URL is built from the provider’s
authorization endpoint and includes various query parameters to ensure
security and proper context tracking:</p>
<ul>
<li>State: this is a high-entropy random string to prevent CSRF; this
package seals the state to enhance security (see below)</li>
<li>PKCE: a <code>code_verifier</code> (random) and
<code>code_challenge</code> (S256 hash) proving the same party finishes
the flow</li>
<li>Nonce (OIDC): random string echoed back in the ID token, mitigating
replay attacks</li>
</ul>
<p>This package seals the state, meaning it encrypts and authenticates
(AES-GCM AEAD) a payload containing:</p>
<ul>
<li>state, client_id, redirect_uri</li>
<li>requested scopes</li>
<li>provider fingerprint (issuer/auth/token URLs)</li>
<li>issued_at timestamp</li>
</ul>
<p>Sealing the state prevents tampering, stale callbacks, and mix-ups
with other providers/clients.</p>
<p>On the server side, the package will store the sealed state (as a
cache-safe hash key) in the state store (e.g., a ‘cachem’ backend) along
with the following data:</p>
<ul>
<li>browser token</li>
<li>code_verifier</li>
<li>nonce (OIDC)</li>
</ul>
<p>All this data will be used for validation during the callback
processing.</p>
</div>
<div id="app-redirects-to-the-provider" class="section level3">
<h3>4. App redirects to the provider</h3>
<p>The browser of the app user will be redirected to the provider’s
authorization endpoint with the following parameters:
<code>response_type=code</code>, <code>client_id</code>,
<code>redirect_uri</code>, <code>state=&lt;sealed state&gt;</code>, PKCE
parameters, <code>nonce</code> (OIDC), <code>scope</code>, plus any
configured extra parameters.</p>
</div>
<div id="user-authenticates-and-authorizes" class="section level3">
<h3>5. User authenticates and authorizes</h3>
<p>Once at the provider’s authorization page, the user is prompted to
log in and authorize the app to access the requested scopes.</p>
</div>
<div id="provider-redirects-user-back-to-the-app" class="section level3">
<h3>6. Provider redirects user back to the app</h3>
<p>The provider redirects the user’s browser back to your Shiny app
(your <code>redirect_uri</code>), including the <code>code</code> and
<code>state</code> parameters (and optionally <code>error</code> and
<code>error_description</code> on failure).</p>
</div>
<div id="callback-processing-state-verification-handle_callback" class="section level3">
<h3>7. Callback processing &amp; state verification
(<code>handle_callback()</code>)</h3>
<p>Once the user is redirected back to the app, the module processes the
callback. This consists of the following steps:</p>
<ul>
<li>Wait for the browser token input if not yet visible</li>
<li>Decrypt and verify the sealed state, ensuring integrity,
authenticity, and freshness (using the <code>issued_at</code>
window)</li>
<li>Check that embedded context matches expected client/provider
(defends against misconfiguration/multi-tenant mix-ups)</li>
<li>Fetch and immediately delete the one-time state entry from the
configured state store
<ul>
<li>If the entry is missing, malformed, or deletion fails, the flow
aborts with a <code>shinyOAuth_state_error</code></li>
<li>Audit events are emitted on failures (e.g.,
<code>audit_state_store_lookup_failed</code>,
<code>audit_state_store_removal_failed</code>)</li>
</ul></li>
<li>Verify that user’s browser token matches the previously stored
browser token</li>
<li>Ensure PKCE components are available when required</li>
</ul>
<p>Note: in asynchronous token exchange mode, the module may pre‑decrypt
the sealed state and prefetch plus remove the state store entry on the
main thread before handing work to the async worker, preserving the same
single‑use and strict failure behavior.</p>
</div>
<div id="exchange-authorization-code-for-tokens" class="section level3">
<h3>8. Exchange authorization code for tokens</h3>
<p>Once the callback is verified, the module proceeds to exchange the
authorization code for tokens.</p>
<p>A POST request is made to the token endpoint with
<code>grant_type=authorization_code</code>, the code, the redirect_uri,
and the <code>code_verifier</code> (PKCE). Client authentication method
depends on provider style: HTTP Basic header
(<code>client_secret_basic</code>), body params
(<code>client_secret_post</code>), or JWT-based assertions
(<code>client_secret_jwt</code>, <code>private_key_jwt</code>) when
configured. The response must include at least
<code>access_token</code>. Malformed or error responses abort the
flow.</p>
<p>When successful, the package also applies two safety rails:</p>
<ul>
<li>If the token response includes <code>scope</code>, all scopes
requested by the client must be present in the granted set; otherwise
the flow fails fast to avoid downstream surprises</li>
<li>If the token response includes <code>token_type</code>, and the
provider was configured with <code>allowed_token_types</code>, the
<code>token_type</code> must be present in the response and be one of
the allowed types (e.g., <code>Bearer</code>). Failure aborts the
flow</li>
</ul>
</div>
<div id="fetch-userinfo-optional" class="section level3">
<h3>9. Fetch userinfo (optional)</h3>
<p>If userinfo is requested via
<code>oauth_provider(userinfo_required = TRUE)</code> (for which you
should have a <code>userinfo_url</code> configured), the module calls
the userinfo endpoint with the access token and stores returned claims.
If this request fails, the flow aborts with an error.</p>
</div>
<div id="validate-id-token-oidc-only" class="section level3">
<h3>10. Validate ID token (OIDC only)</h3>
<p>When using <code>oauth_provider(id_token_validation = TRUE)</code>,
the following verifications are performed:</p>
<ul>
<li>Signature: verified against provider JWKS (with optional thumbprint
pinning) for RS256/ES256; HS256 only with explicit opt-in and
server-held secret</li>
<li>Claims: <code>iss</code> matches expected issuer; <code>aud</code>
vector contains <code>client_id</code>; <code>sub</code> present;
<code>iat</code> is required and must be a single finite numeric;
time-based claims (<code>exp</code> is required, <code>nbf</code>
optional) are evaluated with a small configurable leeway; tokens issued
in the future are rejected</li>
<li>Nonce: must match the previously stored value (if configured)</li>
<li>Subject match: if
<code>oauth_provider(userinfo_id_token_match = TRUE)</code>, it is
checked that <code>sub</code> in userinfo equals <code>sub</code> in the
ID token</li>
</ul>
</div>
<div id="build-the-oauthtoken-object" class="section level3">
<h3>11. Build the <code>OAuthToken</code> object</h3>
<p>Now that all verifications have passed, the module builds the final
token object. This is an S7 <code>OAuthToken</code> object which
contains:</p>
<ul>
<li><code>access_token</code> (string)</li>
<li><code>refresh_token</code> (optional string)</li>
<li><code>expires_at</code> (POSIXct; optional)</li>
<li><code>id_token</code> (optional string)</li>
<li><code>userinfo</code> (optional list)</li>
</ul>
<p>The <code>$authenticated</code> value as returned by
<code>oauth_module_server()</code> now becomes TRUE, meaning all
requested verifications have passed.</p>
</div>
<div id="clean-url-tidy-ui-clear-browser-token" class="section level3">
<h3>12. Clean URL &amp; tidy UI; clear browser token</h3>
<p>The user’s browser was redirected to your app with OAuth query
parameters (<code>code</code>, <code>state</code>, etc.). To improve UX
and avoid leaking sensitive data, these values are removed from the
address bar with JavaScript. Optionally, the page title may also be
adjusted (see the <code>tab_title_</code> arguments in
<code>oauth_module_server()</code>).</p>
<p>The browser token cookie is also cleared to allow a fresh future
flow.</p>
</div>
<div id="post-flow-session-management" class="section level3">
<h3>13. Post-flow session management</h3>
<p>Now that the flow is complete, the module will manage the token
lifetime during the active session. This may consist of:</p>
<ul>
<li>Proactive refresh: if enabled and a refresh token exists, the access
token is refreshed before expiry</li>
<li>Expiration: expired tokens are cleared automatically, setting the
<code>$authenticated</code> flag to FALSE</li>
<li>Re-authentication: optionally,
<code>oauth_module_server(reauth_after_seconds = ...)</code> can force
periodic re-authentication</li>
</ul>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

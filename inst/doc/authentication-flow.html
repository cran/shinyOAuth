<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Authentication flow</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Authentication flow</h1>



<div id="overview" class="section level2">
<h2>Overview</h2>
<p>This vignette provides a step-by-step description of what happens
during an authentication flow when using the
<code>oauth_module_server()</code> Shiny module. It maps protocol
concepts (OAuth 2.0 Authorization Code + PKCE, OpenID Connect) to the
concrete implementation details in the package.</p>
<p>For a concise quick-start (minimal and manual button examples,
options, and security checklist) see:
<code>vignette(&quot;usage&quot;, package = &quot;shinyOAuth&quot;)</code>.</p>
<p>For an explanation of logging key events during the flow, see:
<code>vignette(&quot;audit-logging&quot;, package = &quot;shinyOAuth&quot;)</code>.</p>
</div>
<div id="what-happens-during-the-authentication-flow" class="section level2">
<h2>What happens during the authentication flow?</h2>
<p>The package implements the OAuth 2.0 ‘Authorization Code’ flow and
optional ‘OpenID Connect’ (OIDC) checks end‑to‑end. Below is the
sequence of operations and the rationale behind each step.</p>
<div id="first-page-load-set-a-browser-token" class="section level3">
<h3>1. First page load: set a browser token</h3>
<p>On the first load of your app, the module sets a small random cookie
in the user’s browser (SameSite=Strict; Secure when over HTTPS). This
browser token is mirrored to Shiny as an input. Its purpose is to ensure
that the same browser that starts the OAuth 2.0 flow is the one that
finishes it (a “double-submit” style CSRF defense).</p>
</div>
<div id="decide-whether-to-start-login" class="section level3">
<h3>2. Decide whether to start login</h3>
<p>If <code>oauth_module_server(auto_redirect = TRUE)</code>, an
unauthenticated session triggers immediate redirection to the provider
authorization endpoint.</p>
<p>If <code>oauth_module_server(auto_redirect = FALSE)</code>, you
manually call <code>$request_login()</code> (e.g., via a button) to do
so.</p>
</div>
<div id="build-the-authorization-url-prepare_call" class="section level3">
<h3>3. Build the authorization URL (<code>prepare_call()</code>)</h3>
<p>To redirect the user to the provider, the module constructs an
authorization request URL. The URL is built from the provider’s
authorization endpoint and includes various query parameters to ensure
security and proper context tracking:</p>
<ul>
<li>State: this is a high-entropy random string to prevent CSRF; this
package seals the state to enhance security (see below)</li>
<li>PKCE: a <code>code_verifier</code> (random) and
<code>code_challenge</code> (S256 hash) proving the same party finishes
the flow</li>
<li>Nonce (OIDC): random string echoed back in the ID token, mitigating
replay attacks</li>
</ul>
<p>This package seals the state, meaning it encrypts and authenticates
(AES-GCM AEAD) a payload containing:</p>
<ul>
<li>state, client_id, redirect_uri</li>
<li>requested scopes</li>
<li>provider fingerprint (issuer/auth/token URLs)</li>
<li>issued_at timestamp</li>
</ul>
<p>Sealing the state prevents tampering, stale callbacks, and mix-ups
with other providers/clients.</p>
<p>On the server side, the package will store the sealed state (as a
cache-safe hash key) in the state store (e.g., a ‘cachem’ backend) along
with the following data:</p>
<ul>
<li>browser token</li>
<li>code_verifier</li>
<li>nonce (OIDC)</li>
</ul>
<p>All this data will be used for validation during the callback
processing.</p>
</div>
<div id="app-redirects-to-the-provider" class="section level3">
<h3>4. App redirects to the provider</h3>
<p>The browser of the app user will be redirected to the provider’s
authorization endpoint with the following parameters:
<code>response_type=code</code>, <code>client_id</code>,
<code>redirect_uri</code>, <code>state=&lt;sealed state&gt;</code>, PKCE
parameters, <code>nonce</code> (OIDC), <code>scope</code>, plus any
configured extra parameters.</p>
</div>
<div id="user-authenticates-and-authorizes" class="section level3">
<h3>5. User authenticates and authorizes</h3>
<p>Once at the provider’s authorization page, the user is prompted to
log in and authorize the app to access the requested scopes.</p>
</div>
<div id="provider-redirects-user-back-to-the-app" class="section level3">
<h3>6. Provider redirects user back to the app</h3>
<p>The provider redirects the user’s browser back to your Shiny app
(your <code>redirect_uri</code>), including the <code>code</code> and
<code>state</code> parameters (and optionally <code>error</code> and
<code>error_description</code> on failure).</p>
</div>
<div id="callback-processing-state-verification-handle_callback" class="section level3">
<h3>7. Callback processing &amp; state verification
(<code>handle_callback()</code>)</h3>
<p>Once the user is redirected back to the app, the module processes the
callback. This consists of the following steps:</p>
<ul>
<li>Wait for the browser token input if not yet visible</li>
<li>Decrypt and verify the sealed state, ensuring integrity,
authenticity, and freshness (using the <code>issued_at</code>
window)</li>
<li>Check that embedded context matches expected client/provider
(defends against misconfiguration/multi-tenant mix-ups)</li>
<li>Fetch and immediately delete the one-time state entry from the
configured state store
<ul>
<li>If the entry is missing, malformed, or deletion fails, the flow
aborts with a <code>shinyOAuth_state_error</code></li>
<li>Audit events are emitted on failures (e.g.,
<code>state_store_lookup_failed</code>,
<code>state_store_removal_failed</code>)</li>
</ul></li>
<li>Verify that user’s browser token matches the previously stored
browser token</li>
<li>Ensure PKCE components are available when required</li>
</ul>
<p>Note: in asynchronous token exchange mode, the module may pre‑decrypt
the sealed state and prefetch plus remove the state store entry on the
main thread before handing work to the async worker, preserving the same
single‑use and strict failure behavior.</p>
</div>
<div id="exchange-authorization-code-for-tokens" class="section level3">
<h3>8. Exchange authorization code for tokens</h3>
<p>Once the callback is verified, the module proceeds to exchange the
authorization code for tokens.</p>
<p>A POST request is made to the token endpoint with
<code>grant_type=authorization_code</code>, the code, the redirect_uri,
and the <code>code_verifier</code> (PKCE). Client authentication method
depends on provider style: HTTP Basic header
(<code>client_secret_basic</code>), body params
(<code>client_secret_post</code>), or JWT-based assertions
(<code>client_secret_jwt</code>, <code>private_key_jwt</code>) when
configured. The response must include at least
<code>access_token</code>. Malformed or error responses abort the
flow.</p>
<p>When successful, the package also applies two safety rails:</p>
<ul>
<li>If the token response includes <code>scope</code>, shinyOAuth can
reconcile it against the requested scopes (defaults to strict
enforcement; configurable via the client <code>scope_validation</code>
setting)</li>
<li>If the provider was configured with a non-empty
<code>allowed_token_types</code>, the token response must include
<code>token_type</code> and its value must be one of the allowed types
(case-insensitive, e.g., <code>Bearer</code>)</li>
</ul>
</div>
<div id="fetch-userinfo-optional" class="section level3">
<h3>9. Fetch userinfo (optional)</h3>
<p>If userinfo is requested via
<code>oauth_provider(userinfo_required = TRUE)</code> (for which you
should have a <code>userinfo_url</code> configured), the module calls
the userinfo endpoint with the access token and stores returned claims.
If this request fails, the flow aborts with an error.</p>
</div>
<div id="validate-id-token-oidc-only" class="section level3">
<h3>10. Validate ID token (OIDC only)</h3>
<p>When using <code>oauth_provider(id_token_validation = TRUE)</code>,
the following verifications are performed:</p>
<ul>
<li>Signature: verified against provider JWKS (with optional pinning)
for standard asymmetric algorithms (RSA-PKCS1, RSA-PSS, ECDSA, EdDSA).
HMAC algorithms (HS256/384/512) are only allowed with explicit opt-in
(<code>options(shinyOAuth.allow_hs = TRUE)</code>) and a sufficiently
strong server-held secret</li>
<li>Claims: <code>iss</code> matches expected issuer; <code>aud</code>
vector contains <code>client_id</code>; <code>sub</code> present;
<code>iat</code> is required and must be a single finite numeric;
time-based claims (<code>exp</code> is required, <code>nbf</code>
optional) are evaluated with a small configurable leeway; tokens issued
in the future are rejected</li>
<li>Header <code>typ</code> (when present): must indicate a JWT
(<code>JWT</code>, case-insensitive). Other values (e.g.,
<code>at+jwt</code>) are rejected for ID tokens</li>
<li>Nonce: must match the previously stored value (if configured)</li>
<li>Subject match: if
<code>oauth_provider(userinfo_id_token_match = TRUE)</code>, it is
checked that <code>sub</code> in userinfo equals <code>sub</code> in the
ID token</li>
</ul>
</div>
<div id="token-introspection-optional" class="section level3">
<h3>11. Token introspection (optional)</h3>
<p>Some providers support RFC 7662 token introspection (an additional
endpoint where the server can ask the provider whether an access token
is currently active and retrieve related metadata).</p>
<p>If you enable <code>introspect = TRUE</code> when creating your
<code>oauth_client()</code>, the module calls the provider’s
introspection endpoint during callback processing and requires the
response to indicate <code>active = TRUE</code>. If introspection is
unsupported by the provider or the introspection request fails, the
login is aborted and <code>$authenticated</code> is not set to
<code>TRUE</code>.</p>
<p>You can optionally enforce additional provider-dependent fields via
<code>oauth_client(introspect_elements = ...)</code>:</p>
<ul>
<li><code>&quot;sub&quot;</code> – require introspection <code>sub</code> to match
the session subject</li>
<li><code>&quot;client_id&quot;</code> – require introspection
<code>client_id</code> to match your OAuth client id</li>
<li><code>&quot;scope&quot;</code> – validate introspection <code>scope</code>
against requested scopes (respects the client’s
<code>scope_validation</code> mode)</li>
</ul>
<p>(Note that not all providers may return each of these fields in
introspection responses.)</p>
</div>
<div id="build-the-oauthtoken-object" class="section level3">
<h3>12. Build the <code>OAuthToken</code> object</h3>
<p>Now that all verifications have passed, the module builds the final
token object. This is an S7 <code>OAuthToken</code> object which
contains:</p>
<ul>
<li><code>access_token</code> (string)</li>
<li><code>refresh_token</code> (optional string)</li>
<li><code>expires_at</code> (numeric timestamp, seconds since epoch;
<code>Inf</code> for non-expiring tokens)</li>
<li><code>id_token</code> (optional string)</li>
<li><code>userinfo</code> (optional list)</li>
</ul>
<p>The <code>$authenticated</code> value as returned by
<code>oauth_module_server()</code> now becomes TRUE, meaning all
requested verifications have passed.</p>
</div>
<div id="clean-url-tidy-ui-clear-browser-token" class="section level3">
<h3>13. Clean URL &amp; tidy UI; clear browser token</h3>
<p>The user’s browser was redirected to your app with OAuth 2.0 query
parameters (<code>code</code>, <code>state</code>, etc.). To improve UX
and avoid leaking sensitive data, these values are removed from the
address bar with JavaScript. Optionally, the page title may also be
adjusted (see the <code>tab_title_</code> arguments in
<code>oauth_module_server()</code>).</p>
<p>The browser token cookie is also cleared and immediately re-issued
with a fresh value, so a future flow can start with a new per-session
token.</p>
</div>
<div id="post-flow-session-management" class="section level3">
<h3>14. Post-flow session management</h3>
<p>Now that the flow is complete, the module will manage the token
lifetime during the active session. This may consist of:</p>
<ul>
<li>Proactive refresh: if enabled and a refresh token exists, the access
token is refreshed before expiry</li>
<li>Expiration: expired tokens are cleared automatically, setting the
<code>$authenticated</code> flag to FALSE</li>
<li>Re-authentication: optionally,
<code>oauth_module_server(reauth_after_seconds = ...)</code> can force
periodic re-authentication</li>
</ul>
<div id="refresh-behavior-refresh_token" class="section level4">
<h4>Refresh behavior (<code>refresh_token()</code>)</h4>
<p>When the module refreshes a session (or when you call
<code>refresh_token()</code> directly), it performs an OAuth 2.0 refresh
token grant against the provider’s token endpoint and updates the
<code>OAuthToken</code> object. This works as follows:</p>
<ul>
<li>A token request is sent with <code>grant_type=refresh_token</code>
and the current <code>refresh_token</code></li>
<li>The response must include a new <code>access_token</code>.
<code>expires_at</code> is updated from <code>expires_in</code> when
present; otherwise it is set to <code>Inf</code></li>
<li>If the provider rotates the refresh token (returns a new
<code>refresh_token</code>), it is stored; otherwise the original is
preserved</li>
<li>If <code>oauth_provider(userinfo_required = TRUE)</code>, userinfo
is re-fetched using the fresh access token</li>
</ul>
<p>With respect to OIDC ID token handling:</p>
<ul>
<li>Per OIDC Core Section 12.2, refresh responses may omit
<code>id_token</code>. When omitted, the original <code>id_token</code>
from the initial login is preserved. Thus, a refresh does not
necessarily revalidate identity</li>
<li>If the provider does return an <code>id_token</code> during refresh,
shinyOAuth enforces OIDC 12.2 subject continuity: the refresh-returned
<code>id_token</code> must have the same <code>sub</code> as the
original <code>id_token</code> from login
<ul>
<li>If an original <code>id_token</code> did not exist in the session,
and the refresh does return one, the refresh fails (cannot establish
subject claim match with no baseline)</li>
<li>If <code>id_token_validation = TRUE</code>, the refresh-returned
<code>id_token</code> is fully validated (signature + claims); the
<code>sub</code> claim match is enforced as part of validation</li>
<li>If <code>id_token_validation = FALSE</code>, shinyOAuth still
enforces the <code>sub</code> match by parsing the JWT payload (ensuring
that the <code>sub</code> claim still matches but without full
validation)</li>
</ul></li>
</ul>
<p>If refresh fails inside <code>oauth_module_server()</code>, the
module exposes the failure via its reactive state (for example,
<code>token_refresh_error</code>). By default it also clears the current
session token; if
<code>oauth_module_server(indefinite_session = TRUE)</code>, the token
is kept but marked stale. In all cases, the <code>$authenticated</code>
flag becomes <code>FALSE</code> while the error is present.</p>
</div>
</div>
<div id="logout-and-token-revocation" class="section level3">
<h3>15. Logout and token revocation</h3>
<p>When <code>auth$logout()</code> is called, the module:</p>
<ol style="list-style-type: decimal">
<li>Attempts to revoke both refresh and access tokens at the provider
(RFC 7009) if a <code>revocation_url</code> is configured. This runs
asynchronously only when
<code>oauth_module_server(async = TRUE)</code></li>
<li>Clears the local session (<code>OAuthToken</code>, browser
cookie)</li>
<li>Emits a <code>&quot;logout&quot;</code> audit event</li>
<li>Re-issues a fresh browser token for subsequent logins</li>
</ol>
<p>You can also revoke tokens directly via
<code>revoke_token(client, token, which = &quot;refresh&quot;)</code>.</p>
<p>To automatically attempt revocation when a Shiny session ends (for
example, a tab close or session timeout), set
<code>revoke_on_session_end = TRUE</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>auth <span class="ot">&lt;-</span> <span class="fu">oauth_module_server</span>(</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>  <span class="st">&quot;auth&quot;</span>,</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>  <span class="at">client =</span> client,</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>  <span class="at">revoke_on_session_end =</span> <span class="cn">TRUE</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>)</span></code></pre></div>
<p>This is best-effort: the session may end while the provider is
unavailable, and revocation failures do not block session cleanup.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
